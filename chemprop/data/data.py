from argparse import Namespace
import random
from typing import Callable, List, Union
import numpy as np
from torch.utils.data.dataset import Dataset
from pymatgen.io.vasp import Poscar


class CrystalDatapoint:
    """A CrystalDatapoint contains a single crystal and its associated features and targets."""

    def __init__(self,
                 crystal_name: str = None,
                 crystal_dict: dict = None,
                 targets: List[float] = None,
                 ari: object = None,
                 gdf: object = None,
                 radius_dic: dict = None,
                 args: Namespace = None
                 ):
        """
        Initializes a CrystalDatapoint, which contains a single crystal.

        # :param line: A list of strings generated by separating a line in a data CSV file by comma.
        # :param args: Arguments.
        # :param features: A numpy array containing additional features (ex. Morgan fingerprint).
        """

        self.name = crystal_name
        self.crystal = Poscar.from_dict(crystal_dict).structure
        self.targets = targets

        # construct atom features
        self.atom_features = np.vstack([ari.get_atom_features(self.crystal[i].specie.number) for i in range(len(self.crystal))])

        # construct bond features
        all_neighbors = self.crystal.get_all_neighbors(r=args.radius, include_index=True)
        all_neighbors = [sorted(neighbors, key=lambda x: x[1]) for neighbors in all_neighbors]

        point_indices, offset_vectors, distances = [], [], []

        for neighbors in all_neighbors:
            if len(neighbors) < args.max_num_neighbors:
                point_indices.append(list(map(lambda x: x[2], neighbors)) + [0] * (args.max_num_neighbors - len(neighbors)))
                offset_vectors.append(list(map(lambda x: list(x[3]), neighbors)) + [[0.0, 0.0, 0.0]] * (args.max_num_neighbors - len(neighbors)))
                distances.append(list(map(lambda x: x[1], neighbors)) + [args.radius + 1.] * (args.max_num_neighbors - len(neighbors)))
            else:
                point_indices.append(list(map(lambda x: x[2], neighbors[:args.max_num_neighbors])))
                offset_vectors.append(list(map(lambda x: list(x[3]), neighbors[:args.max_num_neighbors])))
                distances.append(list(map(lambda x: x[1], neighbors[:args.max_num_neighbors])))

        # (len(crystal), args.max_number_neighbors)
        self.point_indices = np.array(point_indices)
        # (len(crystal), args.max_number_neighbors, gdf_array_dimensions)
        self.bond_features = np.concatenate([np.array(offset_vectors), gdf.expand(np.array(distances))], axis=-1)

    def num_tasks(self) -> int:
        """
        Returns the number of prediction tasks.

        :return: The number of tasks.
        """
        return len(self.targets)

    def set_targets(self, targets: List[float]):
        """
        Sets the targets of a crystal.

        :param targets: A list of floats containing the targets.
        """
        self.targets = targets


class CrystalDataset(Dataset):
    """A CrystalDataset contains a list of crystals and their associated features and targets."""

    def __init__(self, data: List[CrystalDatapoint], args: Namespace = None):
        """
        Initializes a CrystalDataset, which contains a list of CrystalDatapoints (i.e. a list of crystals).

        :param data: A list of CrystalDatapoints.
        """
        self.data = data
        self.args = args
        self.scaler = None

    def names(self) -> List[str]:
        """
        Returns the crystal names associated with the crystal (if they exist).

        :return: A list of crystal names or None if the dataset does not contain crystal names.
        """
        if len(self.data) == 0 or self.data[0].name is None:
            return []
        else:
            return [d.name for d in self.data]

    def crystals(self) -> List[Poscar]:
        """
        Returns the structure associated with the crystal.

        :return: A list of Poscar crystal structures.
        """
        return [d.crystal for d in self.data]

    def targets(self) -> List[List[float]]:
        """
        Returns the targets associated with each crystal.

        :return: A list of lists of floats containing the targets.
        """
        return [d.targets for d in self.data]

    def num_tasks(self) -> int:
        """
        Returns the number of prediction tasks.

        :return: The number of tasks.
        """
        return self.data[0].num_tasks() if len(self.data) > 0 else None

    def shuffle(self, seed: int = None):
        """
        Shuffles the dataset.

        :param seed: Optional random seed.
        """
        if seed is not None:
            random.seed(seed)
        random.shuffle(self.data)

    def set_targets(self, targets: List[List[float]]):
        """
        Sets the targets for each crystal in the dataset. Assumes the targets are aligned with the datapoints.

        :param targets: A list of lists of floats containing targets for each crystal. This must be the
        same length as the underlying dataset.
        """
        assert len(self.data) == len(targets)
        for i in range(len(self.data)):
            self.data[i].set_targets(targets[i])

    def sort(self, key: Callable):
        """
        Sorts the dataset using the provided key.

        :param key: A function on a CrystalDatapoint to determine the sorting order.
        """
        self.data.sort(key=key)

    def __len__(self) -> int:
        """
        Returns the length of the dataset (i.e. the number of crystals).

        :return: The length of the dataset.
        """
        return len(self.data)

    def __getitem__(self, item) -> Union[CrystalDatapoint, List[CrystalDatapoint]]:
        """
        Gets one or more CrystalDatapoints via an index or slice.

        :param item: An index (int) or a slice object.
        :return: A CrystalDatapoint if an int is provided or a list of CrystalDatapoints if a slice is provided.
        """
        return self.data[item]
